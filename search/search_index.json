{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Qnatk Qnatk is a RAD (Rapid Application Development) framework for building web applications. It is designed to be simple and easy to use, and to allow developers to build applications quickly. This is not a standalone framework but works with a predefined set of tools and libraries. It is designed to work with the following tools and libraries: Quasar as frontend framework NestJS as backend framework Sequelize as ORM This package is a set of two packages, one for the frontend and one for the backend. The frontend package is a Quasar project and the backend package is a NestJS project. The two packages are designed to work together and are designed to be used together. NOTE: Also, since this is still under development there is no npm package available but you have to include this as a git submodule . Qnatk-Q Qnatk-Q is a set of vue composables that are designed to work with Quasar. It is designed to be simple and easy to use, and to allow developers to focus on main logic of the application. Qnatk-N Qnatk-N is a set of NestJS Module that introduces a Hook based approach to NestJS applications and provides graphQl style auto generated CRUD operations api for Sequelize models.","title":"Home"},{"location":"#welcome-to-qnatk","text":"Qnatk is a RAD (Rapid Application Development) framework for building web applications. It is designed to be simple and easy to use, and to allow developers to build applications quickly. This is not a standalone framework but works with a predefined set of tools and libraries. It is designed to work with the following tools and libraries: Quasar as frontend framework NestJS as backend framework Sequelize as ORM This package is a set of two packages, one for the frontend and one for the backend. The frontend package is a Quasar project and the backend package is a NestJS project. The two packages are designed to work together and are designed to be used together. NOTE: Also, since this is still under development there is no npm package available but you have to include this as a git submodule .","title":"Welcome to Qnatk"},{"location":"#qnatk-q","text":"Qnatk-Q is a set of vue composables that are designed to work with Quasar. It is designed to be simple and easy to use, and to allow developers to focus on main logic of the application.","title":"Qnatk-Q"},{"location":"#qnatk-n","text":"Qnatk-N is a set of NestJS Module that introduces a Hook based approach to NestJS applications and provides graphQl style auto generated CRUD operations api for Sequelize models.","title":"Qnatk-N"},{"location":"qnatk-q/","text":"Qnatk-Q","title":"Qnatk-Q"},{"location":"qnatk-q/#qnatk-q","text":"","title":"Qnatk-Q"},{"location":"quasar/installation/","text":"Qnatk Q Vue composables and Components for Quasar Installation Qnatk is actively under development and is not yet available as an npm package. You can include it as a git submodule in your project. cd your-project git submodule init git submodule add git@github.com:gowrav-vishwakarma/qnatk-q.git src/qnatk and that's it ...","title":"Installation"},{"location":"quasar/installation/#qnatk-q","text":"","title":"Qnatk Q"},{"location":"quasar/installation/#vue-composables-and-components-for-quasar","text":"","title":"Vue composables and Components for Quasar"},{"location":"quasar/installation/#installation","text":"Qnatk is actively under development and is not yet available as an npm package. You can include it as a git submodule in your project. cd your-project git submodule init git submodule add git@github.com:gowrav-vishwakarma/qnatk-q.git src/qnatk and that's it ...","title":"Installation"},{"location":"quasar/quick-start/","text":"Qnatk-Q QuickStart Qnatk is just a set of composables and only a few components. To make most of it you can opt in for best practices for your project as follows: Qnatk consists of following composables: useDataTable : A composable to handle data table operations useForm : A composable to handle form operations Before using the composables it is always advisable to create a wrapper around the composables with your own api (axios instance). create a file under composable in src named anything like this use-MyForm.js and add following code: import { useForm } from 'src/qnatk/composibles/use-form'; import { api } from 'boot/axios'; // eslint-disable-next-line @typescript-eslint/no-explicit-any export function useMMForm( initialUrl: string, // eslint-disable-next-line @typescript-eslint/no-explicit-any defaultValues: Record<string, any>, METHOD: 'post' | 'get' = 'post' ) { return useForm(api, initialUrl, defaultValues, METHOD); } In the same way you can create a wrapper for useDataTable composable. import { useDatatable } from 'src/qnatk/composibles/use-datatable'; import { TransformedSortOption } from 'src/qnatk/QnatkListDTO'; import { api } from 'boot/axios'; // eslint-disable-next-line @typescript-eslint/no-explicit-any export function useMMDataTable<T = any>( baseModel: string, baseUrl = 'qnatk', transformSortBy: (sortBy: string) => string | TransformedSortOption = ( sortBy ) => sortBy ) { return useDatatable<T>(api, baseModel, baseUrl, transformSortBy); } This saves you to import api in every component and you can work with multiple api's in your project. And following components: AutoComplete : A component to handle auto complete operations SingleRecordActions : A component to handle single record actions NoRecordActions : A component to handle no record actions MultiRecordActions : A component to handle multi record actions SimpleForm : A component to handle simple form operations","title":"Quick Start"},{"location":"quasar/quick-start/#qnatk-q-quickstart","text":"Qnatk is just a set of composables and only a few components. To make most of it you can opt in for best practices for your project as follows: Qnatk consists of following composables: useDataTable : A composable to handle data table operations useForm : A composable to handle form operations Before using the composables it is always advisable to create a wrapper around the composables with your own api (axios instance). create a file under composable in src named anything like this use-MyForm.js and add following code: import { useForm } from 'src/qnatk/composibles/use-form'; import { api } from 'boot/axios'; // eslint-disable-next-line @typescript-eslint/no-explicit-any export function useMMForm( initialUrl: string, // eslint-disable-next-line @typescript-eslint/no-explicit-any defaultValues: Record<string, any>, METHOD: 'post' | 'get' = 'post' ) { return useForm(api, initialUrl, defaultValues, METHOD); } In the same way you can create a wrapper for useDataTable composable. import { useDatatable } from 'src/qnatk/composibles/use-datatable'; import { TransformedSortOption } from 'src/qnatk/QnatkListDTO'; import { api } from 'boot/axios'; // eslint-disable-next-line @typescript-eslint/no-explicit-any export function useMMDataTable<T = any>( baseModel: string, baseUrl = 'qnatk', transformSortBy: (sortBy: string) => string | TransformedSortOption = ( sortBy ) => sortBy ) { return useDatatable<T>(api, baseModel, baseUrl, transformSortBy); } This saves you to import api in every component and you can work with multiple api's in your project. And following components: AutoComplete : A component to handle auto complete operations SingleRecordActions : A component to handle single record actions NoRecordActions : A component to handle no record actions MultiRecordActions : A component to handle multi record actions SimpleForm : A component to handle simple form operations","title":"Qnatk-Q QuickStart"},{"location":"quasar/use-data-table/","text":"useDataTable A composable to handle data table operations. useDatatable <T> ( api: AxiosInstance, baseModel: string, baseUrl = 'qnatk', transformSortBy: (sortBy: string) => string | TransformedSortOption = ( sortBy ) => sortBy ) Returns data: Ref<T[]> - The data to be displayed in the table. pagination: Ref<QPagination> - The pagination options. loading: Ref<boolean> - The loading state of the table. fetchData: () => Promise<void> - A function to fetch the data. onRequest: (request: QTableRequest) => void - A function to handle the table request. downloadData: () => Promise<void> - A function to download the data as a CSV file. callBacks: DataTableCallBacks - A set of callback functions to handle table operations. downloadRowIterator: (row: T) => Record<string, any> - A function to transform the row data for the CSV download. rowIterator: (row: T) => Record<string, any> - A function to transform the row data for the table. aclCan: (actionName: string, baseModel: string): boolean => true - A function to check if the user has permission to perform an action. fetchOptions: Ref<ModelOptions> - The fetch options to be used when fetching the data. lacHookName: Ref<string> - The name of the hook to be used when fetching the data. error: Ref<Error | null> - The error state of the table. fetchOptions The fetch options to be used when fetching the data. it mimics sequelize model options with additional properties like include, where, subQuery, etc. following operators are supported in where clause: $or $and $eq $ne $gte $gt $lte $lt $not $in $notIn $like $notLike $iLike $notILike $regexp $notRegexp $iRegexp $notIRegexp $between $notBetween $fullText To check null values you can use following (Case Sensitive) values: '$null$' and '$notNull$' as follows fetchOptions.value = { include: [ { model: 'User', as: 'createdBy', attributes: ['id', 'name'], }, ], where: { $or: { taskId: props.taskId, parentActivityId: props.taskId, }, parentActivityId: '$null$', }, order: ['createdAt', 'desc'], }; <template> <div> <q-btn label=\"Download CSV\" icon=\"cloud_download\" @click=\"downloadData\" /> <q-table title=\"User List\" :rows=\"data\" :columns=\"columns\" :pagination.sync=\"pagination\" :loading=\"loading\" row-key=\"id\" @request=\"onRequest\" > </q-table> </div> </template> <script setup lang=\"ts\"> // Other imports import { useMyDatatable } from 'src/composables/use-my-datatable-wrapper'; const { data, pagination, loading, fetchData, onRequest, downloadData, callBacks, lacHookName } = useMyDatatable('YourBackendModelName'); // lacHookName [optional] // 1) To bypass default autoApi calling and reach to named hook // 2) with ?BeInformed will distinguish the request in network for easy debug and monitoring lacHookName.value = '?BeInformed'; const userStore = useUserStore(); // Define default table pagination sort options, then follows table columns sorting pagination.value.sortBy = 'lastActivityCreatedAt'; pagination.value.descending = true; // Define table columns const columns:QTableColumn[] = [ { name: 'name', label: 'Name', field: 'name', align: 'left', sortable: true }, { name: 'email', label: 'Email', field: 'email', align: 'left', sortable: true }, // Add more columns as needed { name: 'actions', label: 'Actions', field: 'actions', align: 'right', sortable: false }, ]; // Custom row iterator for CSV download to flatten nested objects if needed callBacks.downloadRowIterator = (row) => ({ Name: row.name, Email: row.email, // Transform or add additional fields as needed for the download }); fetchOptions.value = { include: [ { model: 'User', as: 'assignedTo', attributes: ['id', 'name', 'departmentId'], }, { model: 'User', as: 'validator', attributes: ['id', 'name', 'departmentId'], }, { model: 'User', as: 'createdBy', attributes: ['id', 'name', 'departmentId'], }, { model: 'TaskUser', as: 'stakeholders', attributes: ['id', 'userId'], }, ], where: { $or: { validatorId: userStore.user?.id, '$stakeholders.userId$': userStore.user?.id, status: ['assigned', 'validated'], }, organizationId: userStore.user?.organizationId, }, subQuery: false, }; onMounted(() => { fetchData(); }); </script>","title":"useDataTable"},{"location":"quasar/use-data-table/#usedatatable","text":"A composable to handle data table operations. useDatatable <T> ( api: AxiosInstance, baseModel: string, baseUrl = 'qnatk', transformSortBy: (sortBy: string) => string | TransformedSortOption = ( sortBy ) => sortBy ) Returns data: Ref<T[]> - The data to be displayed in the table. pagination: Ref<QPagination> - The pagination options. loading: Ref<boolean> - The loading state of the table. fetchData: () => Promise<void> - A function to fetch the data. onRequest: (request: QTableRequest) => void - A function to handle the table request. downloadData: () => Promise<void> - A function to download the data as a CSV file. callBacks: DataTableCallBacks - A set of callback functions to handle table operations. downloadRowIterator: (row: T) => Record<string, any> - A function to transform the row data for the CSV download. rowIterator: (row: T) => Record<string, any> - A function to transform the row data for the table. aclCan: (actionName: string, baseModel: string): boolean => true - A function to check if the user has permission to perform an action. fetchOptions: Ref<ModelOptions> - The fetch options to be used when fetching the data. lacHookName: Ref<string> - The name of the hook to be used when fetching the data. error: Ref<Error | null> - The error state of the table.","title":"useDataTable"},{"location":"quasar/use-data-table/#fetchoptions","text":"The fetch options to be used when fetching the data. it mimics sequelize model options with additional properties like include, where, subQuery, etc. following operators are supported in where clause: $or $and $eq $ne $gte $gt $lte $lt $not $in $notIn $like $notLike $iLike $notILike $regexp $notRegexp $iRegexp $notIRegexp $between $notBetween $fullText To check null values you can use following (Case Sensitive) values: '$null$' and '$notNull$' as follows fetchOptions.value = { include: [ { model: 'User', as: 'createdBy', attributes: ['id', 'name'], }, ], where: { $or: { taskId: props.taskId, parentActivityId: props.taskId, }, parentActivityId: '$null$', }, order: ['createdAt', 'desc'], }; <template> <div> <q-btn label=\"Download CSV\" icon=\"cloud_download\" @click=\"downloadData\" /> <q-table title=\"User List\" :rows=\"data\" :columns=\"columns\" :pagination.sync=\"pagination\" :loading=\"loading\" row-key=\"id\" @request=\"onRequest\" > </q-table> </div> </template> <script setup lang=\"ts\"> // Other imports import { useMyDatatable } from 'src/composables/use-my-datatable-wrapper'; const { data, pagination, loading, fetchData, onRequest, downloadData, callBacks, lacHookName } = useMyDatatable('YourBackendModelName'); // lacHookName [optional] // 1) To bypass default autoApi calling and reach to named hook // 2) with ?BeInformed will distinguish the request in network for easy debug and monitoring lacHookName.value = '?BeInformed'; const userStore = useUserStore(); // Define default table pagination sort options, then follows table columns sorting pagination.value.sortBy = 'lastActivityCreatedAt'; pagination.value.descending = true; // Define table columns const columns:QTableColumn[] = [ { name: 'name', label: 'Name', field: 'name', align: 'left', sortable: true }, { name: 'email', label: 'Email', field: 'email', align: 'left', sortable: true }, // Add more columns as needed { name: 'actions', label: 'Actions', field: 'actions', align: 'right', sortable: false }, ]; // Custom row iterator for CSV download to flatten nested objects if needed callBacks.downloadRowIterator = (row) => ({ Name: row.name, Email: row.email, // Transform or add additional fields as needed for the download }); fetchOptions.value = { include: [ { model: 'User', as: 'assignedTo', attributes: ['id', 'name', 'departmentId'], }, { model: 'User', as: 'validator', attributes: ['id', 'name', 'departmentId'], }, { model: 'User', as: 'createdBy', attributes: ['id', 'name', 'departmentId'], }, { model: 'TaskUser', as: 'stakeholders', attributes: ['id', 'userId'], }, ], where: { $or: { validatorId: userStore.user?.id, '$stakeholders.userId$': userStore.user?.id, status: ['assigned', 'validated'], }, organizationId: userStore.user?.organizationId, }, subQuery: false, }; onMounted(() => { fetchData(); }); </script>","title":"fetchOptions"},{"location":"quasar/use-form/","text":"useForm A composable to handle form operations. <template> <q-page class=\"row items-center justify-center\"> <q-form @submit.prevent=\"validateAndSubmit\"> <q-card class=\"q-ma-md\" style=\"max-width: 400px\"> <q-card-section> <div class=\"text-h6\">Register</div> <q-input v-model=\"values.email\" label=\"Email\" :error=\"!!errors.email\" :error-message=\"errors.email ? errors.email.join('; ') : ''\" /> <q-input v-model=\"values.password\" label=\"Password\" type=\"password\" :rules=\"[ (val) => val.length > 5 || 'Password must be at least 6 characters', ]\" /> <q-input v-model=\"values.confirmPassword\" label=\"Confirm Password\" type=\"password\" :rules=\"[ (val) => (val === values.password && !!val) || 'Passwords do not match', ]\" /> </q-card-section> <q-card-actions align=\"right\"> <q-btn label=\"Login\" color=\"secondary\" @click=\"goToLogin\" flat /> <q-btn label=\"Register\" color=\"primary\" type=\"submit\" /> </q-card-actions> </q-card> </q-form> </q-page> </template> <script setup lang=\"ts\"> // Assuming you have a similar setup for registration import { useMMForm } from 'src/composibles/use-mm-form'; import { useRouter } from 'vue-router'; const router = useRouter(); const { values, validateAndSubmit, callbacks, errors } = useMMForm( '/auth/register', { email: '', password: '', } ); callbacks.onSuccess = () => { // Handle successful registration console.log('Registration success'); router.push('/login'); }; const goToLogin = () => { router.push('/login'); // Navigate to the registration page }; </script>","title":"useForm"},{"location":"quasar/use-form/#useform","text":"A composable to handle form operations. <template> <q-page class=\"row items-center justify-center\"> <q-form @submit.prevent=\"validateAndSubmit\"> <q-card class=\"q-ma-md\" style=\"max-width: 400px\"> <q-card-section> <div class=\"text-h6\">Register</div> <q-input v-model=\"values.email\" label=\"Email\" :error=\"!!errors.email\" :error-message=\"errors.email ? errors.email.join('; ') : ''\" /> <q-input v-model=\"values.password\" label=\"Password\" type=\"password\" :rules=\"[ (val) => val.length > 5 || 'Password must be at least 6 characters', ]\" /> <q-input v-model=\"values.confirmPassword\" label=\"Confirm Password\" type=\"password\" :rules=\"[ (val) => (val === values.password && !!val) || 'Passwords do not match', ]\" /> </q-card-section> <q-card-actions align=\"right\"> <q-btn label=\"Login\" color=\"secondary\" @click=\"goToLogin\" flat /> <q-btn label=\"Register\" color=\"primary\" type=\"submit\" /> </q-card-actions> </q-card> </q-form> </q-page> </template> <script setup lang=\"ts\"> // Assuming you have a similar setup for registration import { useMMForm } from 'src/composibles/use-mm-form'; import { useRouter } from 'vue-router'; const router = useRouter(); const { values, validateAndSubmit, callbacks, errors } = useMMForm( '/auth/register', { email: '', password: '', } ); callbacks.onSuccess = () => { // Handle successful registration console.log('Registration success'); router.push('/login'); }; const goToLogin = () => { router.push('/login'); // Navigate to the registration page }; </script>","title":"useForm"}]}